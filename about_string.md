​	之前对Class文件常量池，常量池，字符串常量池以及运行时常量池和静态常量池傻傻分不清。现在也是qaq。不过还是先梳理一下，感觉自己理解的还不是很深刻。现在就此记录一下目前的理解。

​	首先要区分概念。据目前的理解：

 1. Class文件常量池应该是指.java文件编译成为.class文件，即字节码文件时。在class文件中的Constant pool 的内容，也就是说Class文件常量池（我看网上也有直接称为Class常量池）跟其他的常量池有本质的不同。其他常量池通常指的是存在内存中的。而Class常量池是存在文件中（即磁盘中的）。通过在网上的简单查阅，发现静态常量池和Class文件常量池是一个意思，应该是每一个.class文件加载入虚拟机时，Class常量池中的常量被加入静态常量池，即静态常量池是Class文件常量池的内存版本。（https://hllvm-group.iteye.com/group/topic/40008），这个链接则说其实静态常量池就是Class文件常量池！

 2. 常量池和字符串常量池：我个人是一直纠结于网上把常量池和字符串常量池混在一起的。难道这两个是值的一个意思？ 个人理解是常量池只是一个笼统的概念，而字符串常量池是其中的代表。

    > -常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
    >
    > 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中
    >
    > - 节省内存空间：常量池中所有相同的字符串常量池被合并，只占用一个空间。
    > - 节省运行时间：比较字符串时，== 比 equals() 快。对于两个引用变量， 只用 ==  判断引用是否相等，也就可以判断实际值是否相等

3. 运行时常量池：运行时常量池是把Class文件常量池加载进来，每个类都有一个独立的运行时常量池。刚开始运行时常量池里的链接都是符号链接，跟在Class文件里一样；边运行边就会把用到的常量转换成直接链接，例如说要Class A 调用 Foo.bar() 方法， A.class 文件里就会有对该方法的Methodref常量，是个符号链接(只有名字没有实体), 加载到运行常量池也还是一样是符号链接，等真的要调用该方法的时候该常量就会被resolve为一个直接链接(直接指向要调用的方法的实体)，解析的过程会去查询全局字符串池，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。

   ​		运行时常量池相对于Class文件常量池的另外一个重要特性就是具备动态性，Java语言并不要求常量只有编译器才能产生，也就是说，并非预置入Class文件中常量池的内容才能进入方法区运行时常量，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是String类的intern() 方法。（intern()方法是把字符串放进运行时常量池？根据实验，应该是还在堆中（JDK7以上），只是把该字符串对象的引用放到了字符串常量池中，但是如果是JDK6时，因为字符串常量池在方法区，所以intern() 方法会把字符串常量池中没有的字符串复制一份到字符串常量池中）

   常量池的变迁：

   ​	运行时常量池一直在方法区，随着方法区由永久代到元空间（JDK8）

   ​	字符串常量池在JDK6时是在方法区，JDK7时移动至堆内存

   因此在JDK6中，intern()方法会把首次遇到的字符串实例（在堆内存）复制到永久代的字符串常量池中存储，而在JDK7及之后，因为字符串常量池已经移动到了堆中，也就没有必要在复制一份存储，只需要在字符串常量池中记录一下即可。

   

   关于intern()方法，intern()方法只是去查看字符串常量池中是否有对应的字符串引用。如果有则返回该引用，没有则新建一个引用将引用指向该字符串。对于调用intern()方法的字符串，其引用不会改变。而intern()返回的引用才是对应于字符串常量池中的引用的值。（JDK7以上的实现）

   https://www.cnblogs.com/feizhai/p/10196955.html

   https://blog.csdn.net/qq_26222859/article/details/73135660

   https://blog.csdn.net/chen1280436393/article/details/51768609

   

   

   