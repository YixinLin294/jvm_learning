# 类加载 class loading
```
在java代码中，类的加载、连接和初始化过程都是在程序运行期间完成的。（类从磁盘加载到内存中经历的三个阶段）
提供了更大的灵活性，增加了更多的可能性。
类加载器深入剖析：
Java虚拟机与程序的生命周期
在如下几种情况下，java虚拟机将结束生命周期
（1）执行了System.exit()方法
（2）程序正常执行结束
（3）程序在执行过程中遇到了异常或错误而异常终止
（4）由于操作系统出现错误而导致虚拟机进程终止
```
## 类的加载、连接与初始化：
### 加载：查找并加载类的二进制数据到java虚拟机中
### 连接：
#### 验证 : 确保被加载的类的正确性
#### 准备：为类的静态变量分配内存，并将其初始化为默认值，但是到达初始化之前类变量都没有初始化为真正的初始值
#### 解析：把类中的符号引用转换为直接引用，就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程
### 初始化：为类的静态变量赋予正确的初始值

## 类从磁盘上加载到内存中要经历五个阶段：加载、连接、初始化、使用、卸载

## Java程序对类的使用方式可分为两种
```
（1）主动使用
（2）被动使用
所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”时才能初始化他们
``` 

### 主动使用（七种）
```
（1）创建类的实例
（2）访问某个类或接口的静态变量 getstatic（助记符），或者对该静态变量赋值 putstatic
（3）调用类的静态方法 invokestatic
（4）反射（Class.forName(“com.test.Test”)）
（5）初始化一个类的子类
（6）Java虚拟机启动时被标明启动类的类
（7）JDK1.7开始提供的动态语言支持（了解）
```
### 被动使用
```
除了上面七种情况外，其他使用java类的方式都被看做是对类的被动使用，都不会导致类的初始化
``` 
### 类的加载详解：
```
类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在方法区中）用来封装内在方法区内的数据结构。
```
#### 加载.calss文件的方式
```
（1）从本地系统中直接加载
（2）通过网络下载.class文件
（3）从zip，jar等归档文件中加载.class文件
（4）从专用数据库中提取.class文件
（5）将java源文件动态编译为.class文件
```
## 测试1：
## 测试2：
## 测试3:
## 测试4:
## 测试5:
## 加载
```
连接（验证、准备、解析）
初始化
类初始化：为新的对象分配内存，为实例变量赋默认值，为实例变量赋正确的初始值
```
```
java编译器在它编译的每一个类都至少生成一个实例化的方法，在java的class文件中，这个实例化方法被称为<init>。针对源代码中每一个类的构造方法，java编译器都会产生一个“<init>”方法。
```

## 有两种类型的类加载器
###Java虚拟机自带的加载器
```
根类加载器（Bootstrap）：该加载器没有父加载器，它负责加载虚拟机中的核心类库。根类加载器从系统属性sun.boot.class.path所指定的目录中加载类库。类加载器的实现依赖于底层操作系统，属于虚拟机的实现的一部分，它并没有集成java.lang.ClassLoader类。
```
```
扩展类加载器（Extension）：它的父加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库，或者从JDK的安装目录的jre\lib\ext子目录（扩展目录）下加载类库，如果把用户创建的jar文件放在这个目录下，也会自动由扩展类加载器加载，扩展类加载器是纯java类，是java.lang.ClassLoader的子类。
```
```
系统应用类加载器（System）：也称为应用类加载器，它的父加载器为扩展类加载器，它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，他是用户自定义的类加载器的默认父加载器。系统类加载器时纯java类，是java.lang.ClassLoader的子类。
``` 
### 用户自定义的类加载器
```
java.lang.ClassLoader的子类
用户可以定制类的加载方式
根类加载器–>扩展类加载器–>系统应用类加载器–>自定义类加载器
类加载器并不需要等到某个类被“首次主动使用”时再加载它
```
### 加载
```
JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在程序首次主动使用该类才报告错误（LinkageError错误），如果这个类没有被程序主动使用，那么类加载器就不会报告错误。
```
```
类加载器用来把类加载到java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能更好地保证Java平台的安全。在此委托机制中，除了java虚拟机自带的根类加载器以外，其余的类加载器都有且只有一个父加载器。当java程序请求加载器loader1加载Sample类时，loader1首先委托自己的父加载器去加载Sample类，若父加载器能加载，则有父加载器完成加载任务，否则才由加载器loader1本身加载Sample类。
```
```
类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
```

### 类的连接-验证
```
1）类文件的结构检查
2）语义检查
3）字节码验证
4）二进制兼容性的验证
```
### 类的连接-准备
```
在准备阶段，java虚拟机为类的静态变量分配内存，并设置默认的初始值。例如对于以下Sample类，在准备阶段，将为int类型的静态变量a分配4个字节的内存空间，并且赋予默认值0，为long类型的静态变量b分配8个字节的内存空间，并且赋予默认值0；
```
### 初始化
```
在初始化阶段，Java虚拟机执行类的初始化语句，为类的静态变量赋予初始值。在程序中，静态变量的初始化有两种途径：（1）在静态变量的声明处进行初始化；（2）在静态代码块中进行初始化。
```
```
类的初始化步骤：
（1）假如这个类还没有被加载和连接，那就先进行加载和连接
（2）假如类存在直接父类，并且这个父类还没有被初始化，那就先初始化直接父类
（3）假如类中存在初始化语句，那就依次执行这些初始化语句
·当java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则不适用于接口。因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定的接口的静态变量时，才会导致该接口的初始化。
·调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。
```

### 类加载器的父亲委托机制
```
在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根加载器之外，其余的类加载器都有一个父加载器

若有一个类能够成功加载Test类，那么这个类加载器被称为定义类加载器，所有能成功返回Class对象引用的类加载器（包括定义类加载器）称为初始类加载器。
https://img-blog.csdnimg.cn/20190823165459877.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zODQwNTM1NA==,size_16,color_FFFFFF,t_70
```
## 测试7
## 测试8
## 测试9-12忽略
## 测试13
## 测试14
## 获取类加载器的途径：
```
（1）clazz.getClassLoader(); --获取当前类的加载器
（2）Thread.currentThread().getContextClassLoader(); --获取当前线程上下文的加载器
（3）ClassLoader.getSystemClassLoader(); --获取系统的加载器
（4）DriverManager.getCallerClassLoader(); --获取调用者的加载器
```
## ClassLoader源码分析与实例剖析–
```
ClassLoader是一个负责加载class的对象，ClassLoader类是一个抽象类，需要给出类的二进制名称，ClassLoader尝试定位或者产生一个class的数据，一个典型的策略是把二进制名字转换成文件名然后到文件系统中找到该文件。
```
## 测试15:
## 测试16:
```
并行类加载器可支持并发加载，需要在类初始化期间调用ClassLoader.registerAaParallelCapable()方法进行注册。ClassLoader类默认支持并发加载，但是其子类必须在初始化期间进行注册。
```

## 命名空间
```
每个类加载器都有自己的命名空间，命名空间由该加载器及所有父加载器所加载的类构成；
在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类；
在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类；
同一命名空间内的类是互相可见的，非同一命名空间内的类是不可见的；
子加载器可以见到父加载器加载的类，父加载器也不能见到子加载器加载的类。
```
## 类的卸载
```
当一个类被加载、连接和初始化之后，它的生命周期就开始了。当此类的Class对象不再被引用，即不可触及时，Class对象就会结束生命周期，类在方法区内的数据也会被卸载。
一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。
由Java虚拟机自带的类加载器所加载的类，在虚拟机的生命周期中，始终不会被卸载。Java虚拟机本身会始终引用这些加载器，而这些类加载器则会始终引用他们所加载的类的Class对象，因此这些Class对象是可触及的。
由用户自定义的类加载器所加载的类是可以被卸载的。
```
## gvisualvm命令 查看当前java进程，在jdk/bin下面
## 测试17
## 测试17_1
## 测试17_1_1
## 关于命名空间重要说明：
```
子加载器所加载的类能够访问父加载器所加载的类；
而父加载器所加载的类无法访问子加载器所加载的类。
```
## 测试18
## 测试18_1
## 测试19
## 测试20
## 测试21
## 类加载器双亲委托模型的好处：
###（1）可以确保Java和核心库的安全
```
所有的Java应用都会引用java.lang中的类，也就是说在运行期java.lang中的类会被加载到虚拟机中，如果这个加载过程如果是由自己的类加载器所加载，那么很可能就会在JVM中存在多个版本的java.lang中的类，而且这些类是相互不可见的（命名空间的作用）。借助于双亲委托机制，Java核心类库中的类的加载工作都是由启动根加载器去加载，从而确保了Java应用所使用的的都是同一个版本的Java核心类库，他们之间是相互兼容的；
```
###（2）确保Java核心类库中的类不会被自定义的类所替代；
###（3）不同的类加载器可以为相同名称的类（binary name）创建额外的命名空间。相同名称的类可以并存在Java虚拟机中，只需要用不同的类加载器去加载即可。相当于在Java虚拟机内部建立了一个又一个相互隔离的Java类空间。
## 父亲委托机制的优点是能够提高软件系统的安全性。因此在此机制下，用户自定义的类加载器不可能加载应该由父类加载器加载的可靠类，从而防止不可靠甚至恶意的代码代替由父类加载器加载的可靠代码。例如，java.lang.Object类是由跟类加载器加载，其他任何用哪个户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。
## 测试22
扩展类加载器只加载jar包，需要把class文件打成jar
测试23
类加载器本身也是类加载器，类加载器又是谁加载的呢？？（先有鸡还是现有蛋）
类加载器是由启动类加载器去加载的，启动类加载器是C++写的，内嵌在JVM中。
内嵌于JVM中的启动类加载器会加载java.lang.ClassLoader以及其他的Java平台类。当JVM启动时，一块特殊的机器码会运行，它会加载扩展类加载器以及系统类加载器，这块特殊的机器码叫做启动类加载器。
启动类加载器并不是java类，其他的加载器都是java类。
启动类加载器是特定于平台的机器指令，它负责开启整个加载过程。
OpenJDK
grepcode.com:源码分析
Launcher类

Class.forName(String name, boolean initialize, ClassLoader loader);
—利用给定的加载器，返回字符串对应的Class对象。当initialize为true时，会对该类进行初始化（该类之前未初始化），默认为true。
Class.forName(“Foo”) 等同于== Class.forName(“Foo”,true,this.getClass.getClassLoader());
上下文类加载器 Thread.getContextClassLoader()
测试24
当前类加载器(Current ClassLoader)
每个类都会尝试使用自己的类加载器去加载依赖的类。
如果ClassX引用ClassY，那么ClassX的类加载器会尝试加载ClassY。（前提是ClassY尚未被加载）
线程上下文类加载器(Context ClassLoader)
线程上下文加载器 @ jdk1.2
线程Thread类中的 getContextClassLoader() 与 setContextClassLoader(ClassLoader loader)
如果没有通过setContextClassLoader()方法设置，线程将继承父线程的上下文类加载器，java应用运行时的初始线程的上下文类加载器是系统类加载器。该线程中运行的代码可以通过该类加载器加载类和资源。
线程上下文类加载器的作用：
父ClassLoader可以使用当前线程Thread.currentThread().getContextClassLoader()所制定的ClassLoader加载的类，这就改变了父加载器加载的类无法使用子加载器或是其他没有父子关系的ClassLoader加载的类的情况，即改变了双亲委托模型。
· 线程上下文类加载器就是当前线程的Current ClassLoader。
在双亲委托模型下，类加载是由下至上的，即下层的类加载器会委托父加载器进行加载。但是有些接口是Java核心库所提供的的（如JDBC），Java核心库是由启动类记载器去加载的，而这些接口的实现却来自不同的jar包（厂商提供），Java的启动类加载器是不会加载其他来源的jar包，这样传统的双亲委托模型就无法满足要求。通过给当前线程设置上下文类加载器，就可以由设置的上下文类加载器来实现对于接口实现类的加载。
测试25
线程上下文类加载器的一般使用模式：获取-使用-还原
伪代码：
ClassLoader classLoader=Thread.currentThread().getContextLoader();
try{
Thread.currentThread().setContextLoader(targetTccl);
myMethod();
}finally{
Thread.currentThread().setContextLoader(classLoader);
}
SPI：Service Provide Interface 服务提供者接口
双亲委托机制在父类加载器加载的类中访问子类加载器加载的类时会出现问题，比如JDBC。JDBC中规定，Driver(数据库驱动)必须向DriverManage注册自己，而DriverManage是BootStrapClassloader加载的，所以DriverManage 中是无法加载到具体的Driver。
此时，服务提供者可以将配置文件放到资源目录的META-INF/services下，高层的接口通过SPI的方式，读取META-INF/services下文件中的类名。
SPI的具体约定为：当服务的提供者提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。当外部程序装配这个模块的时候，就能通过该jar包META-INF/services里的配置文件找到具体的实现类，并装载实例化，完成模块的注入。基于这一个约定就能很好的找到服务接口的实现类，而不需要在代码里指定。jdk提供服务实现查找的一个工具类：java.util.ServiceLoader

测试27—JDBC案例分析
当调用DriverManager的静态方法是，会造成类的初始化
在loadInitialDrivers()方法的代码中，可以发现DriverManager加载Driver的包括两部分：
1.通过System.getProperty(“jdbc.drivers”)进行获取，使用系统类加载器进行加载。但是系统参数"jdbc.drivers"为null，因此不会进行Driver的加载；
2.通过SPI的方式，读取META-INF/services文件夹下的类名，使用当前线程类加载器进行加载。
DriverManager初始化完毕，我们再来看一下mysql提供的Driver类内部的情况

↓ com.mysql.jdbc.Driver是java.sql.Driver的具体实现类，在初始化时会向DriverManager注册自己。就是将自身加入到一个名为registeredDrivers的静态成员CopyOnWriteArrayList中。但是实际中，Driver已经在初始化的过程总使用SPI的方式将其进行了注册。
ServiceLoader
ServiceLoader是由BootStrap Classloader加载的，所以类中引用的其它类也会由BootStrap 尝试去加载。
到此为止，DriverManager类在初始化的过程中，已经使用SPI的方式将mysql提供的Driver加载完毕。
最后再来看看DriverManager调用DriverManager.getConnection( “URL”,“user”,“password”)的内容：
//使用了mysql提供的具体方法获取连接。